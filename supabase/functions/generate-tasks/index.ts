// Setup type definitions for built-in Supabase Runtime APIs
import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { GoogleGenerativeAI } from "npm:@google/generative-ai@0.21.0";
import { z } from "npm:zod";

type RequestPayload = {
  projectTitle: string,
  goals: {title: string, success: string}[]
  constraints: string[],
  context: string
  guardrails: { 
    security: string[],
    standards: string[],
    ethics: string[],
    product_principles: string[]
    other: string
  }
}

// cleans the zod JsonSchema object of keys "$schema" and "additionalProperties" 
// generated by ai
function cleanSchemaForGemini(schema: any) {
  // If it's not an object (or it's null), return it as-is
  if (typeof schema !== 'object' || schema === null) {
    return schema;
  }

  // Handle Arrays: Clean every element in the array
  if (Array.isArray(schema)) {
    return schema.map(item => cleanSchemaForGemini(item));
  }

  // Handle Objects
  const cleaned = {};
  
  // List of keys to strictly exclude
  const forbiddenKeys = ['$schema', 'additionalProperties'];

  for (const [key, value] of Object.entries(schema)) {
    // Skip the forbidden keys
    if (forbiddenKeys.includes(key)) {
      continue;
    }

    // Special Handling for anyOf/oneOf
    // If we find an anyOf that includes "null", convert it to the standard "nullable: true"
    if (key === 'anyOf' && Array.isArray(value)) {
      const types = value.map(v => v.type).filter(Boolean);
      const isNullable = value.some(v => v.type === 'null');
      
      if (types.includes('string')) {
        cleaned['type'] = 'string';
      } else if (types.includes('number') || types.includes('integer')) {
        cleaned['type'] = 'number';
      }
      
      if (isNullable) {
        cleaned['nullable'] = true;
      }
      continue; // Skip the original anyOf key
    }

    // Recursively clean the value
    cleaned[key] = cleanSchemaForGemini(value);
  }

  return cleaned;
}

Deno.serve(async (req: Request) => {

  // JsonSchema Constraints 
  const githubIssueSchema = z.object({
      title: z.union([z.string(), z.number().int() ]).describe("A Title describing the Issue"),
      body: z.string().describe("The Description of the issue"),
      assignee: z.string().nullable().describe("The assignee of the issue"),
      milestone: z.union([ z.string(), z.number() ]).nullable().describe("The milestone of the issue"),
      labels: z.array(z.string()).describe("The labels of the issue"),
  });
  const githubIssueListSchema = z.object({tasks: z.array(githubIssueSchema).describe("the tasks of the issue")});

  try {

    const { projectTitle, goals, constraints, context, guardrails }: RequestPayload = await req.json();
    const apiKey = Deno.env.get("GOOGLE_API_KEY");
    if (!apiKey) throw new Error("Missing GOOGLE_API_KEY");

    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ model: "gemini-3-flash-preview" });

    const prompt = `
Extract the recipe into JSON. 

STRICT RULES:
1. The JSON must be syntactically correct
2. when using number type as value for title and milestone they must be an int
3. labels need to be a list of string
4. FOLLOW THE JSON STRUCTURE
5. MAX TASKS GENERATED IN THE JSON LIST IS 24
6. 

THE FINAL JSON STRUCTURE IS REQUIRED:
{
  tasks : {
    title : string | number, // number must be int
    body : string,
    assignee : string | null,
    milestone: null | string | number // number must be int
    labels: string[]
  }[]
}

ASSUME THIS IS FOR GITHUB ISSUES
Take the role of a software requirements engineer and create tasks using the format of the required JSON.

Make sure that there are clear frontend and backend tasks. This means if given a framework, programming language, sdk, library, api, environment, architecture, etc.
create the tasks for each functional requirement and Non-functional requirement specifying if front end work is required the components or the algorithms are needed for the backend. If none of those are specified choose them for the user when creating that tasks. Lastly dont push mutliple tasks into one tasks make sure
that they are scoped enough to be done by one person. For example and example for frontend work dont do make a task for frontend components but make one for a specific component. Make sure to label the non-functional and functional requirements with their respective labels.

Use the Following data when i say START to heavily support the creation of the tasks making sure everything is accounted and end when i say STOP 
for they are shown in the format,

CATEOGORY
DATA

START

The Goals of The Project (Functional Requirements)
${goals}

The Constraints of The Project (Non-Functional Requirements)
${constraints}

The Context of The Project (the over idea for the project known as the product vision and possibly the overall purpose of the organization)
${context}

The Guardrails of the project (More Non-Functional Requirements)
${guardrails}

STOP
`;

    // Generates Json based on the prompt  
    const result = await model.generateContent({
      contents: [{
        role: "user",
        parts: [{ text: prompt }]
      }],
      generationConfig: {
        responseMimeType: "application/json",
        responseSchema: cleanSchemaForGemini(githubIssueListSchema.toJSONSchema()),
        temperature: 0,
      },
    });
    const responseText = await result.response.text();
    const jsonResponse = githubIssueListSchema.parse(JSON.parse(responseText));

    return new Response(JSON.stringify(jsonResponse), { 
      headers: { 'Content-Type': 'application/json' },
      status: 200 
    });
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), { 
      headers: { 'Content-Type': 'application/json' },
      status: 500 
    });
  }
});